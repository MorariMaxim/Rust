let data = input.data;
    let mut i = 1;
    match data {
        Data::Struct(the_struct) => match the_struct.fields {
            Fields::Named(ref fields) => {
                for field in fields.named.iter() {
                    for attr in field.attrs.iter() {
                        
                        
                        if let Ok(meta) = attr.parse_meta() {
                            match meta {
                                syn::Meta::NameValue(nv) => {
                                    if let Some(id) = nv.path.get_ident() {
                                        
                                        let lit = nv.lit;
                                        if let syn::Lit::Int(val) = lit {
                                            println!("{} = {}", id.to_string(), val.base10_digits());
                                        }
                                        else {
                                            println!(
                                                "not a int val {}",
                                                lit.into_token_stream().to_string()
                                            );
                                        }

                                    } else {
                                        println!(
                                            "not a ident path {}",
                                            nv.path.into_token_stream().to_string()
                                        );
                                    }
                                }
                                _ => {
                                    println!(
                                        "not a namevalue attirbute {}",
                                        meta.into_token_stream().to_string()
                                    );
                                }
                            }
                        } else {
                            println!("not meta attirbutes {}", attr.tokens.to_string());
                        } 
                    }
                }
            }

            _ => {
                unimplemented!()
            }
        },
        _ => {
            unimplemented!()
        }
    }







// checking fields, spannign
match data {
        Data::Struct(the_struct) => match the_struct.fields {
            Fields::Named(ref fields) => {
                let span = fields.named.iter().next();
                let span = span.unwrap();
                let span = span.ident.span();

                let mut span = proc_macro2::Span::call_site();
                let mut i = 1;
                let recurse = fields.named.iter().map(|f| {
                    let func_name = format_ident! ("randfn_{}", f.ty.to_token_stream().to_string());
                    
                    quote_spanned! {f.ty.span() =>
                        fn #func_name(id: i32) {
                            println!("{}", bit_serde::serialize(&id));
                        }   
                    }
                });

                result = quote! {

                    #(#recurse)*
                };
            }

            _ => {
                unimplemented!()
            }
        },
        _ => {
            unimplemented!()
        }
    } 